/*=========================================================================*/
/* Fellow                                                                  */
/*                                                                         */
/* Sound emulation                                                         */
/*                                                                         */
/* Author: Petter Schau                                                    */
/*                                                                         */
/* Copyright (C) 1991, 1992, 1996 Free Software Foundation, Inc.           */
/*                                                                         */
/* This program is free software; you can redistribute it and/or modify    */
/* it under the terms of the GNU General Public License as published by    */
/* the Free Software Foundation; either version 2, or (at your option)     */
/* any later version.                                                      */
/*                                                                         */
/* This program is distributed in the hope that it will be useful,         */
/* but WITHOUT ANY WARRANTY; without even the implied warranty of          */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           */
/* GNU General Public License for more details.                            */
/*                                                                         */
/* You should have received a copy of the GNU General Public License       */
/* along with this program; if not, write to the Free Software Foundation, */
/* Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.          */
/*=========================================================================*/

#include "defs.h"
#include "chipset.h"
#include "fmem.h"
#include "sound.h"
#include "wav.h"
#include "cia.h"
#include "graph.h"
#include "sounddrv.h"
#include "interrupt.h"


#define MAX_BUFFER_SAMPLES 65536


/*===========================================================================*/
/* Sound emulation configuration                                             */
/*===========================================================================*/

sound_rates sound_rate;                               /* Current output rate */
bool sound_stereo;                            /* Current mono/stereo setting */
bool sound_16bits;                               /* Current 8/16 bit setting */
sound_emulations sound_emulation;
sound_filters sound_filter;
sound_notifications sound_notification;
BOOLE sound_wav_capture;
BOOLE sound_device_found;
uint32_t sound_volume;


/*===========================================================================*/
/* Buffer data                                                               */
/*===========================================================================*/

uint32_t sound_current_buffer;
int16_t sound_left[2][MAX_BUFFER_SAMPLES],
sound_right[2][MAX_BUFFER_SAMPLES];         /* Samplebuffer, 16-b.signed */
uint32_t sound_buffer_length;                      /* Current buffer length in ms */
uint32_t sound_buffer_sample_count;    /* Current number of samples in the buffer */
uint32_t sound_buffer_sample_count_max;         /* Maximum capacity of the buffer */


/*===========================================================================*/
/* Information about the sound device                                        */
/*===========================================================================*/

sound_device sound_dev;


/*===========================================================================*/
/* Run-time data                                                             */
/*===========================================================================*/

uint32_t audiocounter;                   /* Used in 22050/44100 to decide samples */
uint32_t audioodd;                          /* Used for skipping samples in 22050 */
uint32_t sound_framecounter;                       /* Count frames, and then play */
uint32_t sound_scale;

double filter_value45 = 0.857270436755215389; // 7000 Hz at 45454 Hz samplingrate
double filter_value33 = 0.809385175167476725; // 7000 Hz at 33100 Hz samplingrate
double filter_value22 = 0.727523105310746957; // 7000 Hz at 22005 Hz samplingrate
double filter_value15 = 0.639362082983339100; // 7000 Hz at 15650 Hz samplingrate
/*
double amplitude_div45 = 3.5000000000;
double amplitude_div33 = 2.8000000000;
double amplitude_div22 = 1.9000000000;
double amplitude_div15 = 1.4000000000;
*/

double amplitude_div45 = 7.035;
double amplitude_div33 = 5.25;
double amplitude_div22 = 3.67;
double amplitude_div15 = 2.773;
double last_right = 0.0000000000;
double last_left = 0.0000000000;


/*===========================================================================*/
/* Audio-registers                                                           */
/*===========================================================================*/

uint32_t audpt[4];                                          /* Sample-DMA pointer */
uint32_t audlen[4];                                                     /* Length */
uint32_t audper[4];                      /* Used directly, NOTE: translated value */ 
uint32_t audvol[4];             /* Volume, possibly not reloaded by state-machine */
uint32_t auddat[4];                           /* Last data word set by DMA or CPU */
BOOLE auddat_set[4];	              /* Set TRUE whenever auddat is written */

/*===========================================================================*/
/* Internal variables used by state-machine                                  */
/*===========================================================================*/

uint32_t audlenw[4];                                            /* Length counter */
uint32_t audpercounter[4];                                      /* Period counter */
uint32_t auddatw[4];                    /* Sample currently output, 16-bit signed */
soundStateFunc audstate[4];                 /* Current state for the channel */
uint32_t audvolw[4];                   /* Current volume, reloaded at some points */
uint32_t audptw[4];               /* Current dma-pointer, reloaded at some points */ 


/*===========================================================================*/
/* Translation tables                                                        */
/*===========================================================================*/

uint32_t periodtable[65536];
int16_t volumes[256][64];
uint32_t audioirqmask[4] = {0x0080, 0x0100, 0x0200, 0x0400};
uint32_t audiodmaconmask[4] = {0x1, 0x2, 0x4, 0x8};


/*==============================================================================
Audio IO Registers
==============================================================================*/

/* Extract channel number from the register address */

uint32_t soundGetChannelNumber(uint32_t address)
{
  return ((address & 0x70) >> 4) - 2;
}


/*
==================
AUDXPT
==================
$dff0a0,b0,c0,d0
*/

void waudXpth(uint16_t data, uint32_t address)
{
  uint32_t ch = soundGetChannelNumber(address);
  audpt[ch] = chipsetReplaceHighPtr(audpt[ch], data);
}

void waudXptl(uint16_t data, uint32_t address)
{
  uint32_t ch = soundGetChannelNumber(address);
  audpt[ch] = chipsetReplaceLowPtr(audpt[ch], data);
}

/*
==================
AUDXLEN
==================
$dff0a4,b4,c4,d4
*/

void waudXlen(uint16_t data, uint32_t address)
{
  uint32_t ch = soundGetChannelNumber(address);
  audlen[ch] = data;
}

/*
==================
AUDXPER
==================
$dff0a6,b6,c6,d6
*/

void waudXper(uint16_t data, uint32_t address)
{
  uint32_t ch = soundGetChannelNumber(address);
  audper[ch] = periodtable[data];
}

/*
==================
AUDXVOL
==================
$dff0a8,b8,c8,d8

*/

void waudXvol(uint16_t data, uint32_t address)
{
  uint32_t ch = soundGetChannelNumber(address);
  /*Replay routines sometimes access volume as a byte register at $dff0X9...*/
  if (((data & 0xff) == 0) && ((data & 0xff00) != 0)) data = (data >> 8) & 0xff;
  if ((data & 64) == 64) data = 63;
  audvol[ch] = data & 0x3f;
}

/*
==================
AUDXDAT
==================
$dff0aa,ba,ca,da

Not used right now.
*/

void waudXdat(uint16_t data, uint32_t address)
{
  uint32_t ch = soundGetChannelNumber(address);
  auddat[ch] = data & 0xff;
  auddat_set[ch] = TRUE;
}


/*==============================================================================
Audio state machine
==============================================================================*/

void soundState0(uint32_t ch);
void soundState1(uint32_t ch);
void soundState2(uint32_t ch);
void soundState3(uint32_t ch);
void soundState4(uint32_t ch);
void soundState5(uint32_t ch);
void soundState6(uint32_t ch);

/*==============================================================================
State 0
==============================================================================*/

void soundState0(uint32_t ch)
{
  /*-------------------
  Statechange 0 to 1
  -------------------*/

  audlenw[ch] = audlen[ch];
  audptw[ch] = audpt[ch];
  audpercounter[ch] = 0;
  audstate[ch] = soundState1;
}

/*==============================================================================
State 1
==============================================================================*/

void soundState1(uint32_t ch)
{
  /*-------------------
  Statechange 1 to 5
  -------------------*/

  if (audlenw[ch] != 1) audlenw[ch]--; 
  audstate[ch] = soundState5;
  wintreq_direct((uint16_t) (audioirqmask[ch] | 0x8000), 0xdff09c, true);
}

/*==============================================================================
State 2
==============================================================================*/

void soundState2(uint32_t ch)
{
  if (audpercounter[ch] >= 0x10000)
  {

    /*-------------------
    Statechange 2 to 3
    -------------------*/

    audpercounter[ch] -= 0x10000;
    audpercounter[ch] += audper[ch];
    audvolw[ch] = audvol[ch];
    audstate[ch] = soundState3;
    auddatw[ch] = volumes[(auddat[ch] & 0xff00) >> 8][audvolw[ch]];
  }
  else
  {
    /*-------------------
    Statechange 2 to 2
    -------------------*/

    audpercounter[ch] += audper[ch];
  }
}

/*==============================================================================
State 3
==============================================================================*/

void soundState3(uint32_t ch)
{
  if (audpercounter[ch] >= 0x10000)
  {
    /*-------------------
    Statechange 3 to 2
    -------------------*/

    audpercounter[ch] -= 0x10000;
    audpercounter[ch] += audper[ch];
    audvolw[ch] = audvol[ch];
    audstate[ch] = soundState2;
    auddatw[ch] = volumes[auddat[ch] & 0xff][audvolw[ch]];
    auddat[ch] = chipmemReadWord(audptw[ch]);
    audptw[ch] = chipsetMaskPtr(audptw[ch] + 2);
    if (audlenw[ch] != 1) audlenw[ch]--;
    else
    {
      audlenw[ch] = audlen[ch];
      audptw[ch] = audpt[ch];
      wintreq_direct((uint16_t) (audioirqmask[ch] | 0x8000), 0xdff09c, true);
    }
  }
  else
  {
    /*-------------------
    Statechange 3 to 3
    -------------------*/

    audpercounter[ch] += audper[ch];
  }
}

/*==============================================================================
State 4 and State 6, no operation
==============================================================================*/

void soundState4(uint32_t ch)
{
}

void soundState6(uint32_t ch)
{
}

/*==============================================================================
State 5
==============================================================================*/

void soundState5(uint32_t ch)
{
  /*-------------------
  Statechange 5 to 2
  -------------------*/

  audvolw[ch] = audvol[ch];
  audpercounter[ch] = 0;
  auddat[ch] = chipmemReadWord(audptw[ch]);
  audptw[ch] = chipsetMaskPtr(audptw[ch] + 2);
  audstate[ch] = soundState2;
  if (audlenw[ch] != 1) audlenw[ch]--;
  else
  {
    audlenw[ch] = audlen[ch];
    audptw[ch] = audpt[ch];
    wintreq_direct((uint16_t) (audioirqmask[ch] | 0x8000), 0xdff09c, true);
  }
}

/*==============================================================================
This is called by DMACON when DMA is turned off
==============================================================================*/

void soundChannelKill(uint32_t ch)
{
  auddatw[ch] = 0;
  audstate[ch] = soundState0;
}

/*==============================================================================
This is called by DMACON when DMA is turned on
==============================================================================*/

void soundChannelEnable(uint32_t ch)
{
  soundState0(ch);
}

/*==============================================================================
Generate sound
Called in every end of line
Will run the audio state machine the needed number of times
and move the generated samples to a temporary buffer
==============================================================================*/

/*==============================================================================
; Audio_Lowpass filters the _sound_right and sound_left memory with a
; pass1 lowpass filter at 7000 Hz
; coded by Rainer Sinsch (sinsch@informatik.uni-frankfurt.de)
;==============================================================================*/

void soundLowPass(uint32_t count, int16_t *buffer_left, int16_t *buffer_right)
{
  double amplitude_div;
  double filter_value;
  switch (soundGetRate())
  {
  case SOUND_44100:
    amplitude_div = amplitude_div45;
    filter_value = filter_value45;
    break;
  case SOUND_31300:
    amplitude_div = amplitude_div33;
    filter_value = filter_value33;
    break;
  case SOUND_22050:
    amplitude_div = amplitude_div22;
    filter_value = filter_value22;
    break;
  case SOUND_15650:
    amplitude_div = amplitude_div15;
    filter_value = filter_value15;
    break;
  }

  for (uint32_t i = 0; i < count; ++i)
  {
    last_left = filter_value*last_left + (double)buffer_left[i];
    buffer_left[i] = (int16_t) (last_left / amplitude_div);
    last_right = filter_value*last_right + (double)buffer_right[i];
    buffer_right[i] = (int16_t) (last_right / amplitude_div);
  }
}

uint32_t soundChannelUpdate(uint32_t ch, int16_t *buffer_left, int16_t *buffer_right, uint32_t count, BOOLE halfscale, BOOLE odd)
{
  uint32_t samples_added = 0;
  uint32_t i;

  if (dmacon & audiodmaconmask[ch])
  {
    for (i = 0; i < count; ++i)
    {
      audstate[ch](ch);
      if ((!halfscale) || (halfscale && !odd))
      {
	if (ch == 0 || ch == 3)
	{
	  buffer_left[samples_added++] += (int16_t) auddatw[ch];
	}
	else
	{
	  buffer_right[samples_added++] += (int16_t) auddatw[ch];
	}
      }
      odd = !odd;
    }
  }
  else
  {
    if (!interruptIsRequested(audioirqmask[ch]) && auddat_set[ch])
    {
      auddat_set[ch] = FALSE;
      wintreq_direct((uint16_t) (audioirqmask[ch] | 0x8000), 0xdff09c, true);
    }
    if (!halfscale)
    {
      samples_added = count;
    }
    else
    {
      for (i = 0; i < count; ++i)
      {
	if (!odd)
	{
	  samples_added++;
	}
	odd = !odd;
      }
    }
  }
  return samples_added;
}

void soundFrequencyHandler()
{
  int16_t *buffer_left = (int16_t*) sound_left + sound_buffer_sample_count;
  int16_t *buffer_right = (int16_t*) sound_right + sound_buffer_sample_count;
  uint32_t count = 0;
  uint32_t samples_added;
  BOOLE halfscale = (soundGetRate() == SOUND_22050 || soundGetRate() == SOUND_15650);
  uint32_t i;
  if (soundGetRate() == SOUND_44100 || soundGetRate() == SOUND_22050)
  {
    while (audiocounter <= 0x40000)
    {
      count++;
      audiocounter += sound_scale;
    }
  }
  else count = 2;
  audiocounter -= 0x40000;
  for (i = 0; i < count; ++i) buffer_left[i] = buffer_right[i] = 0;
  for (i = 0; i < 4; ++i) samples_added = soundChannelUpdate(i, buffer_left, buffer_right, count, halfscale, audioodd);
  if (halfscale && count & 1) audioodd = !audioodd;

  if (sound_filter != SOUND_FILTER_NEVER)
  {
    if (sound_filter == SOUND_FILTER_ALWAYS || ciaIsSoundFilterEnabled())
      soundLowPass(samples_added, buffer_left, buffer_right);
  }
  sound_buffer_sample_count += samples_added;
}

/*===========================================================================*/
/* Property settings                                                         */
/*===========================================================================*/

__inline void soundSetRate(sound_rates rate)
{
  sound_rate = rate;
}

__inline sound_rates soundGetRate()
{
  return sound_rate;
}

__inline uint32_t soundGetRateReal()
{
  switch (soundGetRate()) {
    case SOUND_44100:	return 44100;
    case SOUND_31300:	return 31300;
    case SOUND_22050:	return 22050;
    case SOUND_15650:	return 15650;
  }
  return 0;
}

__inline void soundSetStereo(bool stereo)
{
  sound_stereo = stereo;
}

__inline bool soundGetStereo()
{
  return sound_stereo;
}

__inline void soundSet16Bits(bool bits16)
{
  sound_16bits = bits16;
}

__inline bool soundGet16Bits()
{
  return sound_16bits;
}

__inline void soundSetEmulation(sound_emulations emulation)
{
  sound_emulation = emulation;
}

sound_emulations soundGetEmulation()
{
  return sound_emulation;
}

__inline void soundSetFilter(sound_filters filter)
{
  sound_filter = filter;
}

__inline sound_filters soundGetFilter()
{
  return sound_filter;
}

__inline void soundSetNotification(sound_notifications notification)
{
  sound_notification = notification;
}

sound_notifications soundGetNotification()
{
  return sound_notification;
}

__inline void soundSetBufferLength(uint32_t ms)
{
  sound_buffer_length = ms;
}

__inline uint32_t soundGetBufferLength()
{
  return sound_buffer_length;
}

__inline uint32_t soundGetVolume()
{
  return sound_volume;
}

__inline void soundSetVolume(const uint32_t volume)
{
  sound_volume = volume;
}

__inline void soundSetWAVDump(BOOLE wav_capture)
{
  sound_wav_capture = wav_capture;
}

__inline BOOLE soundGetWAVDump()
{
  return sound_wav_capture;
}

__inline void soundSetBufferSampleCount(uint32_t sample_count)
{
  sound_buffer_sample_count = sample_count;
}

__inline uint32_t soundGetBufferSampleCount()
{
  return sound_buffer_sample_count;
}

__inline void soundSetBufferSampleCountMax(uint32_t sample_count_max)
{
  sound_buffer_sample_count_max = sample_count_max;
}

__inline uint32_t soundGetBufferSampleCountMax()
{
  return sound_buffer_sample_count_max;
}

__inline void soundSetDeviceFound(BOOLE device_found)
{
  sound_device_found = device_found;
}

__inline BOOLE soundGetDeviceFound()
{
  return sound_device_found;
}

__inline void soundSetScale(uint32_t scale)
{
  sound_scale = scale;
}

__inline uint32_t soundGetScale()
{
  return sound_scale;
}

__inline void soundSetSampleVolume(uint8_t sample_in, uint8_t volume, int16_t sample_out)
{
  volumes[sample_in][volume] = sample_out;
}

__inline int16_t soundGetSampleVolume(int8_t sample_in, uint8_t volume)
{
  return volumes[sample_in][volume];
}

__inline void soundSetPeriodValue(uint32_t period, uint32_t value)
{
  periodtable[period] = value;
}

__inline uint32_t soundGetPeriodValue(uint32_t period)
{
  return periodtable[period];
}


/*===========================================================================*/
/* Initializes the volume table                                              */
/*===========================================================================*/

void soundVolumeTableInitialize(BOOLE stereo)
{
  int32_t s;

  if (!stereo)
    s = 1;                                                           /* Mono */
  else
    s = 2;                                                         /* Stereo */

  for (int32_t i = -128; i < 128; i++) 
    for (int32_t j = 0; j < 64; j++)
      if (j == 0)
	soundSetSampleVolume((uint8_t) (i & 0xff), (uint8_t) j, (int16_t)  0);
      else
	soundSetSampleVolume((uint8_t) (i & 0xff), (uint8_t) j, (int16_t) ((i*j*s)));
}


/*===========================================================================*/
/* Initializes the period table                                              */
/*===========================================================================*/

void soundPeriodTableInitialize(uint32_t outputrate)
{
  if (outputrate < 29000)
    outputrate *= 2;   /* Internally, can not run slower than max Amiga rate */
  soundSetScale((uint32_t) (((double)(65536.0*2.0*31200.0))/((double) outputrate)));

  soundSetPeriodValue(0, 0x10000);
  for (int32_t i = 1; i < 65536; i++)
  {
    //j = 3568200 / i;                                          /* Sample rate */
    double j = 3546895 / i;                                          /* Sample rate */
    int32_t periodvalue = (uint32_t)((j * 65536) / outputrate);
    if (periodvalue > 0x10000)
      periodvalue = 0x10000;
    soundSetPeriodValue(i, periodvalue);
  }
}


/*===========================================================================*/
/* Sets up sound emulation for a specific quality                            */
/*===========================================================================*/

void soundPlaybackInitialize()
{
  audiocounter = 0;
  if (soundGetEmulation() > SOUND_NONE)
  {                      /* Play sound */
    soundPeriodTableInitialize(soundGetRateReal());
    soundVolumeTableInitialize(soundGetStereo());
    soundSetBufferSampleCount(0);
    sound_current_buffer = 0;
    soundSetBufferSampleCountMax(static_cast<uint32_t>(static_cast<float>(soundGetRateReal()) / (1000.0f / static_cast<float>(soundGetBufferLength()))));
  }
}


/*===========================================================================*/
/* Clear a device struct                                                     */
/*===========================================================================*/

void soundDeviceClear(sound_device *sd)
{
  memset(sd, 0, sizeof(sound_device));
}


/*===========================================================================*/
/* Set IO register stubs                                                     */
/*===========================================================================*/

void soundIOHandlersInstall()
{
  for (int i = 0; i < 4; i++)
  {
    memorySetIoWriteStub(0xa0 + 16*i, waudXpth);
    memorySetIoWriteStub(0xa2 + 16*i, waudXptl);
    memorySetIoWriteStub(0xa4 + 16*i, waudXlen);
    memorySetIoWriteStub(0xa6 + 16*i, waudXper);
    memorySetIoWriteStub(0xa8 + 16*i, waudXvol);
    memorySetIoWriteStub(0xaa + 16*i, waudXdat);
  }
}


/*===========================================================================*/
/* Clear all sound emulation data                                            */
/*===========================================================================*/

void soundIORegistersClear()
{
  audstate[0] = soundState0;
  audstate[1] = soundState0;
  audstate[2] = soundState0;
  audstate[3] = soundState0;

  for (int i = 0; i < 4; i++)
  {
    audpt[i] = 0;
    audptw[i] = 0;
    audlen[i] = 2;
    audper[i] = 0;
    audvol[i] = 0;
    audpercounter[i] = 0;
    auddat[i] = 0;
    auddat_set[i] = FALSE;
    auddatw[i] = 0;
    audlenw[i] = 2;
    audvolw[i] = 0;
  }
  sound_current_buffer = 0;
}


void soundCopyBufferOverrunToCurrentBuffer(uint32_t available_samples, uint32_t previous_buffer)
{
  uint32_t pos = 0;
  for (uint32_t i = soundGetBufferSampleCountMax(); i < available_samples; i++)
  {
    sound_left[sound_current_buffer][pos] = sound_left[previous_buffer][i];
    sound_right[sound_current_buffer][pos] = sound_right[previous_buffer][i];
    pos++;
  }
  soundSetBufferSampleCount(pos + MAX_BUFFER_SAMPLES*sound_current_buffer);
}

/*===========================================================================*/
/* Called on end of line                                                     */
/*===========================================================================*/

void soundEndOfLine()
{
  if (soundGetEmulation() != SOUND_NONE)
  {
    soundFrequencyHandler();
    uint32_t available_samples = soundGetBufferSampleCount() - sound_current_buffer*MAX_BUFFER_SAMPLES;
    if (available_samples >= soundGetBufferSampleCountMax())
    {
      if (soundGetEmulation() == SOUND_PLAY)
      {
        soundDrvPlay(sound_left[sound_current_buffer], sound_right[sound_current_buffer], soundGetBufferSampleCountMax());
      }
      if (soundGetWAVDump())
      {
        wavPlay(sound_left[sound_current_buffer], sound_right[sound_current_buffer], soundGetBufferSampleCountMax());
      }
      int previous_buffer = sound_current_buffer;
      sound_current_buffer++;
      if (sound_current_buffer > 1)
      {
        sound_current_buffer = 0;
      }
      soundSetBufferSampleCount(0 + MAX_BUFFER_SAMPLES*sound_current_buffer);

      if (available_samples > soundGetBufferSampleCountMax())
      {
        soundCopyBufferOverrunToCurrentBuffer(available_samples, previous_buffer);
      }
    }
  }
}


/*===========================================================================*/
/* Called on emulation start and stop                                        */
/*===========================================================================*/

void soundEmulationStart()
{
  soundIOHandlersInstall();
  audioodd = 0;
  soundPlaybackInitialize();
  if (soundGetEmulation() != SOUND_NONE && soundGetEmulation() != SOUND_EMULATE)
  {
    /* Allow sound driver to override buffer length */
    uint32_t buffer_length = soundGetBufferSampleCountMax();
    if (!soundDrvEmulationStart(soundGetRateReal(), soundGet16Bits(), soundGetStereo(), &buffer_length))
    {
      soundSetEmulation(SOUND_EMULATE); /* Driver failed, slient emulation */
    }
    if (buffer_length != soundGetBufferSampleCountMax())
    {
      soundSetBufferSampleCountMax(buffer_length);
    }
  }
  if (soundGetWAVDump() && (soundGetEmulation() != SOUND_NONE))
  {
    wavEmulationStart(soundGetRate(), soundGet16Bits(), soundGetStereo(), soundGetBufferSampleCountMax());
  }
}

void soundEmulationStop()
{
  if (soundGetEmulation() != SOUND_NONE && soundGetEmulation() != SOUND_EMULATE)
    soundDrvEmulationStop();
  if (soundGetWAVDump() && (soundGetEmulation() != SOUND_NONE))
    wavEmulationStop();
}


/*===========================================================================*/
/* Called every time we do a hard-reset                                      */
/*===========================================================================*/

void soundHardReset()
{
  soundIORegistersClear();
}


/*===========================================================================*/
/* Called once on emulator startup                                           */
/*===========================================================================*/

BOOLE soundStartup()
{
  soundSetEmulation(SOUND_NONE);
  soundSetFilter(SOUND_FILTER_ORIGINAL);
  soundSetRate(SOUND_15650);
  soundSetStereo(FALSE);
  soundSet16Bits(FALSE);
  soundSetNotification(SOUND_MMTIMER_NOTIFICATION);
  soundSetWAVDump(FALSE);
  soundSetBufferLength(40);
  soundIORegistersClear();
  soundDeviceClear(&sound_dev);
  soundSetDeviceFound(soundDrvStartup(&sound_dev));
  wavStartup();
  if (!soundGetDeviceFound())
    if (soundGetEmulation() == SOUND_PLAY)
      soundSetEmulation(SOUND_NONE);
  return soundGetDeviceFound();
}


/*===========================================================================*/
/* Called once on emulator shutdown                                          */
/*===========================================================================*/

void soundShutdown()
{
  soundDrvShutdown();
}
